---------- Doubts -------------
1. what is CSRF attack and what is the use of CSRF token?

2. What is Cross site scripting attack?

3. What is broken authentication ?

4. How do we whitelist some endpoints to be not part of Spring Security authentication?

5. Is each endpoint mapped to one servlet class ?
Ans : No, each servlet can be mapped to multiple endpoints by mapping url patterns.

6. If we define two beans of same type then what would happen?

---------- XXXXX ---------------



Security like availability, scalability and performance are non functional requirements.

Clients won't ask for non functional requirement but it is a must to have.


Note: we would need to use @ComponentScan with argument as corresponding folder path for Spring context to load up corresponding
	  beans in Spring context.

Note: whenever we add Spring Security dependency then we would need to supply username and password to access our applications with 
	  default username as user and password would be auto generated by spring security on the console.	
	  

---- Servlets and Filters :

So HTTP protocol is not understood by our Java business code.

Hence, we need some mechanism to convert payload in HTTP request to constructs which Java can comprehend.
This work is done by servlet containers (web server) like Tomcat.

Servlet container converts the HttpRequest to ServletRequest object and hand it over to servlet as parameter.

So, Java web apps are drived by Servlet i.e. Servlet are the building blocks of web application.
	  
Similarly, we have filters which can be used to intercept each request before forwarding it to Servlet.


Client --- request ---> Filters ---> Servlets

App/Web server basically comprises of Filters and Servlets.

Note: Spring security uses these filters only for enforcing security constraints.
 

---- Building blocks of Spring Security :

1. Spring Security Filters : This is the first point of contact for client's request.
							 It forms Authentication object and can be used to perform first level of authentication.

2. Authentication object : This is the POJO on which authentication business logic would be performed.

3. Authentication Manager : This takes Authentication object as input and based on certain criteria delegate it to Authentication Providers
							which actually has the business logic to perform validation.

4. Authentication Provider : These are the actual classes where business logic for authentication and authorization is present.
							 It will leverage inbuilt classes (e.g. Password Encoder, UserDetails Manager/Service) to perform the operation 
							 or we can create our custom implementation as well.

5. Security Context : After performing all 4 operations above, Authentication object is stored in Security Context which is basically used as a
					  session to allow subsequent requests to pass on without re-performing all validation steps.	
									
Note: Revisit this section and distinguish classes and interfaces among building blocks.
									

---- Important Filters to be aware of :

1. AuthorizationFilter.java

2. DefaultLoginPageGeneratingFilter.java

3. UsernamePasswordAuthenticationFilter.java

4. ProviderManager.java (Implementation of AuthenticationManager)

5. DaoAuthenticationProvider.java.
   However, by default we have AnonymousAuthenticationProvider.java which implements interface AuthenticationProvider.
									

---- Why subsequent requests after getting authenticated once need not be authenticated again ?	

Note: If you login once from a browser then it will allow you to access the APIs without relogin.
	  However, if you switch to a different browser then we need to re-login.
	  This is because they are using cookie to store the session in the field called JSESSIONID.

Interestingly, it compares the JSESSIONID value in backend so technically it's a String match operation only.	  
	  

---- Custom Security configuration at API level.

SpringBootWebSecurityConfiguration class' method defaultSecurityFilterChain is called when any rest API is called 
and it by default secures all the endpoints.

First class that is loaded is ApplicationFilterChain and the corresponding method is internalDoFilter().

To write our own filter to whitelist some of the APIs, I think we would need to override this class and provide our own implementation.
So, we need to define bean of type SecurityFilterChain as per the documentation over the concerned method.

/**
The default configuration for web security. It relies on Spring Security's content-negotiation strategy to determine what sort of authentication to use. 
If the user specifies their own SecurityFilterChain bean, this will back-off completely 
and the users should specify all the bits that they want to configure as part of the custom security configuration.
**/

We can use @Configuration annotation over class and define a bean within it to override default SecurityFilterChain bean.

If you define multiple beans of the same type in @Configuration file then first one in order of declaration is considered.