

--

Note that atomicity is defined only from the perspective of the caller of the operation, 
because almost no atomic action—including machine instructions—is truly atomic at all levels of implementation.

At hardware level, the block on disk can be left half-changed, and the controller returns an error code indicating that this happened.

It might even produce a normal return code in spite of the fact that, 
due to some transient error in the controller’s circuitry or a fault in the disk media, the block was not written correctly. 
And if there is a power loss in the middle of the operation, it might happen that the first part of the block is written, but the rest is not. 
In all these cases the outcome of the action is neither all nor nothing, but something in between.

---- ACID :

Atomic : Everything or nothing.

Consistency : Abiding by the constraints of the application.

Isolation : Forms an illusion that application is accessed by single user only.

Durability : Once transaction is committed, information is expected to be preserved in the system even in case of crash.

A flat transaction like what we have used usually is useful to divide our application into chunks of atomic processing units.

Note :

Complex updates are supported by savepoints or by nested transactions, bulk updates are supported by chained transactions or sagas, and so on.
This overcomes the limitation of flat transactions all or nothing approach.


Flat transactions have finally made their way into all commercially available database systems, 
and they are about to be used in operating systems and communication systems. 
The implementation techniques are well-understood, and so are the limitations.

---- Save Point :

A savepoint is established by invoking the SAVE WORK function, which causes the system to record the current state of processing. 
This returns to the application program a handle that can subsequently be used to refer to that savepoint.

 It is worthwhile considering the subtle difference between rolling a transaction back completely (aborting it) 
 and rolling back to savepoint 1. In the first case, the transaction disappears from the scene, 
 gets detached from the program that was running it, and loses all its resources. 
 When rolling back to savepoint 1, the transaction stays alive, keeps its resources, and simply returns to a state where it has not yet done anything.
 
 
 Continue : one paragraph before 4.5.2 Developing the Rules for the Savepoint Model