--- Concurrency (130 pages)

concurrency is basically dividing a task into multiple tasks that may or may not execute at the same time.


********************* Homework *********************

-- Understand how threads are created and started : 

   basically understand native code thread.start() 

-- Understand how Future's get() method behaves, does it block untill all tasks are ready or it blocks untill corresponding future task is ready.
 Ans : we call get on a particular future object so it waits untill that particular Future is ready.

***************************************************

-- Moore's law :

The number of transistors that can be placed on an IC doubles after every two years.

-- process :

A process is a self-contained program running within its own address space. 
A multitasking operating system can run more than one process (program) at a time 
by periodically switching the CPU from one process to another, 
while making it look as if each process is chugging along on its own.

In contrast, concurrent systems like the one used in Java share resources like memory and I/O, so the fundamental difficulty in writing multithreaded programs 
is coordinating the use of these resources between different thread-driven tasks, 
so that they cannot be accessed by more than one task at a time.

Each task executes as a process in its own address space, so there’s no possibility of interference between tasks. 
More importantly, there’s no need for the tasks to communicate with each other because they’re all completely independent.

-- Java doesn't support creating multiple processes but multiple threads within a process.

Instead of forking external processes in a multitasking operating system, 
threading creates tasks within the single process represented by the executing program.

Java’s threading is preemptive, which means that a scheduling mechanism provides time slices for each thread, 
periodically interrupting a thread and context switching to another thread so that each one is given a reasonable amount of time to drive its task.

Using multithreading, each of these independent tasks (also called subtasks) is driven by a thread of execution. 

"A thread is a single sequential flow of control within a process."

A single process can thus have multiple concurrently executing tasks, but you program as if each task has the CPU to itself.

so basically, even multithreaeding guarantees concurrent execution but not simultaneous execution.


--- Task :

Task is performed by threads.
To define a task simply implement Runnable.

Thread.yield() -- signals thread executor to schedule other task which is not mandatory though.

--- Thread class :

Each Thread "registers" itself so there is actually a reference to it someplace, 
and the garbage collector can’t clean it up until the task exits its run( ) and dies.

RunnableExample runnableExample = new RunnableExample();
Thread thread = new Thread(runnableExample);

Flow is like below :

1. Create a thread using syntax : Thread t = new Thread();

2. Now, you have to assign a task or critical section that this thread must execute which is defined by Runnable interface's run method.

3. t = new Thread(<Runnable object reference>)

-- native keyword

e.g. private native void start0() 

The native keyword in Java is used in method declarations to indicate that the method is implemented in a platform-dependent way,
 typically in another programming language like C or C++. When a method is declared as native,
 it means that the implementation of that method is provided by a non-Java source code, and it must be linked to the Java code at runtime.
 
 
 



--- Executors :

Note : It is present in java.util.concurrent package.

Before Executors, client directly manages lifecycle of a thread.

After Executors, client delegates this responsibility to Executor,
i.e. we can use Executor instead of directly creating threads (It uses command design pattern).

-- FixedThreadPool Executor Service - upfront decide number of threads that is needed.
Syntax : ExecutorService exec = Executors.newFixedThreadPool(<num of threads>);

-- CachedThreadPool Executor Service - depends on the load underlying library decides the number of threads that needs to be executed.
Syntax : ExecutorService exec = Executors.newCachedThreadPool();

e.g. this will create 15 threads for CachedThreadPool:

for(int i =0; i<15; i++)
            executorService.execute(new RunnableExample());
			
-- SingleThreadExecutor : It provisions only one thread and it serializes the tasks that is submitted to it and maintain an inherent queue for the same.
Syntax : ExecutorService exec = Executors.newSingleThreadExecutor();

Note: ExecutorService extends Executor interface and implementation class of execute is ThreadPoolExecutor.

Note : From ThreadPoolExecutor documentation :

		 * If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command(Runnable object) as its first
         * task
		 
		 For FixedThreadPool, it is defined by number of threads that is passed as parameter in Syntax above.
		 For CachedThreadPool, it is decided by JVM at runtime based on the maximumPoolSize value.
		 
Note : Volatile keyword

In Java, the volatile keyword is used to indicate that a variable's value may be modified asynchronously by multiple threads. 
When a variable is declared as volatile, the Java memory model ensures that any write to that variable is immediately visible to all other threads 
that access that variable.	 

--- Producing return values from a task :

A Runnable is a separate task that performs work but it doesn't return a value.
If we want our task to return a value then we need to implement Callable interface (this is Generic i.e. Callable<Some Type>) rather than Runnable interface.



***** Creation of thread at OS level ******

The creation of a thread involves several steps:

1. Allocation of resources: The kernel allocates the necessary resources to support a new thread, 
including a unique thread identifier, a stack, and a register context.

2. Setting up the thread's initial state: The kernel sets up the initial state of the new thread, 
including setting the program counter to the starting address of the thread's code.

3. Registering the thread with the scheduler: The kernel registers the new thread with the scheduler, 
which is responsible for determining which thread should be executed next.

4. Scheduling the thread: Once the new thread has been registered with the scheduler, 
the scheduler determines when to start executing the thread based on a variety of factors, 
including the priority of the thread and the availability of system resources.

5. Execution: Once the thread is scheduled to run, the kernel sets up the necessary hardware context to allow the thread to execute, 
and the thread begins executing its code.

--- Sleeping :

Important :
The call to sleep( ) can throw an InterruptedException, and you can see that this is caught in run( ). 
Because exceptions won’t propagate across threads back to main( ), 
you must locally handle any exceptions that arise within a task.

Syntax :

In run() method :
TimeUnit.MILLISECONDS.sleep(100);

--- Priority :

The priority of a thread conveys the importance of a thread to the scheduler. 
Although the order in which the CPU runs a set of threads is indeterminate, 
the scheduler will lean toward running the waiting thread with the highest priority first. 
However, this doesn’t mean that threads with lower priority aren’t run (so you can’t get deadlocked because of priorities).
Lower-priority threads just tend to run less often.

Syntax : 
Thread.currentThread().setPriority(priority);

--- Yield :

When you call yield( ), you are suggesting that other threads of the same priority might be run.
This is just a hint to scheduler and doesn't guarantee anything.

-- yield() vs sleep() :

sleep : It pauses the thread for specified time during which thread is not scheduled by the scheduler i.e. it isn't active and ready to run during sleep timing.
yiled : It hints scheduler that it can be context switched with other thread but it will remain active and ready to run.


--- Daemon threads :

Daemon thread runs in the background and is active untill the process that spawned this thread is running.
Syntax :
Thread thread = new Thread();
thread.setDaemon(true);

Note :::

You should be aware that daemon threads will terminate their run( ) methods without executing finally clauses.

--- Terminology :

Thread has a task (class that implements Runnable).

--- Joining a thread :

If a thread calls t.join( ) on another thread t, then the calling thread is suspended until the target thread t finishes (when t.isAlive( ) is false). 

--- To make UI non blocking :

use daemon process and put the calculation inside a run( ) method to allow it to be preempted.