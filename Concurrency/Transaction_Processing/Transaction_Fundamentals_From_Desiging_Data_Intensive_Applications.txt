---------------------------- Doubts ------------------------------------
1. Is there any way to just have atomic operations without using transaction ? (I think that's what optimistic locking is e.g. AtomicInteger etc)?

2. What is the role of Storage Engine?

3. What exactly is a secondary index?











--------------------------- XXXXX ---------------------------------------------------


A transaction is a way for an application to group several reads and writes
together into a logical unit. Conceptually, all the reads and writes in a transaction are
executed as one operation: either the entire transaction succeeds (commit) or it fails
(abort, rollback).



-- The Slippery Concept of a Transaction

Almost all relational databases today, and some nonrelational databases, support transactions.


-- Atomicity :

In multi-threaded programming, if one thread executes an atomic
operation, that means there is no way that another thread could see the half-finished
result of the operation. 

In a nutshell, atomicity is basically that the system can only be in the state it was before the operation or after the operation, not something in between.

-- Consistency :

Consistent hashing is an approach to partitioning that some systems use for rebalancing.

In the context of ACID, consistency refers to an application-specific notion of the database being in a “good state”.
i.e. it should be in a correct state wrt to the use case like debit and credit reconciliation.


Atomicity, isolation, and durability are properties of the database, whereas consistency (in the ACID sense) is a property of the application. 
The application may rely on the database’s atomicity and isolation properties in order to achieve consistency,
but it’s not up to the database alone.

-- Isolation :

The classic database
textbooks formalize isolation as serializability, which means that each transaction can
pretend that it is the only transaction running on the entire database. The database
ensures that when the transactions have committed, the result is the same as if they
had run serially (one after another), even though in reality they may have run concurrently.

However, in practice, serializable isolation is rarely used, because it carries a performance penalty.


-- Durability :

Durability is the promise that once a transaction has committed successfully, any data it has written will not be forgotten, even if there is a
hardware fault or the database crashes.

In a single-node database, durability typically means that the data has been written to nonvolatile storage such as a hard drive or SSD. 
It usually also involves a write-ahead log.

In a replicated database, durability may mean that the data has been successfully copied to some number of nodes.

-- Single-Object and Multi-Object Operations :

Single Object basically denotes same table and Multi-Object denotes multiple tables in context of relational database.


Dirty read :
One transaction reads another transaction's uncommitted writes.


For Single Object :

Atomicity can be implemented using a log for crash recovery
(see “Making B-trees reliable” on page 82), and isolation can be implemented
using a lock on each object (allowing only one thread to access an object at any one
time).

Similarly popular is a compare-and-set operation, which allows a write to
happen only if the value has not been concurrently changed by someone else (see
“Compare-and-set” on page 245).

Compare-and-set and other single-object operations have been dubbed “lightweight
transactions” or even “ACID” for marketing purposes, but that
terminology is misleading. A transaction is usually understood as a mechanism for
grouping multiple operations on multiple objects into one unit of execution.

-- Handling errors and aborts :

If you want to make sure that several different systems either commit or
abort together, two-phase commit can help (we will discuss this in “Atomic
Commit and Two-Phase Commit (2PC)” on page 354)


-- Weak Isolation Levels :

Concurrency issues (race conditions) only
come into play when one transaction reads data that is concurrently modified by
another transaction, or when two transactions try to simultaneously modify the same
data.

In practice, isolation is unfortunately not that simple. Serializable isolation has a performance
cost, and many databases don’t want to pay that price. It’s therefore
common for systems to use weaker levels of isolation, which protect against some
concurrency issues, but not all. Those levels of isolation are much harder to understand,
and they can lead to subtle bugs, but they are nevertheless used in practice.

"Rather than blindly relying on tools, we need to develop a good understanding of the
kinds of concurrency problems that exist, and how to prevent them."

In this section, we will look at several weak (nonserializable) isolation levels.


-- Read Committed :

The most basic level of transaction isolation is read committed. 

It makes two guarantees:

1. When reading from the database, you will only see data that has been committed.
(no dirty reads).
2. When writing to the database, you will only overwrite data that has been committed
(no dirty writes).

What exactly is dirty read ?

Imagine a transaction has written some data to the database, but the transaction has
not yet committed or aborted. Can another transaction see that uncommitted data? If
yes, that is called a dirty read.

Transactions running at the read committed isolation level must prevent dirty reads.
This means that any writes by a transaction only become visible to others when that
transaction commits (and then all of its writes become visible at once).


-- Continue : No dirty writes