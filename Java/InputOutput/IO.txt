--- File class:

-- File class:
   -- File path = new File(<any path, if not given then current directory>); // This basically works on the path provided as argument.
      path.list(<any class that implements FileNameFilter interface>);
   -- we can also make directories using path.mkdirs();
   
-- Strategy design pattern : It is basically callback mechanism i.e. based on the parameter underlying implementation is being invoked.

-- Streams :
   -- Any data source or sink capable of producing or receiving pieces of data.
   
-- Input/Output Streams :
	-- For reading, Everything is derived from InputStream or Reader class which has a method called read() for reading a single byte or array of bytes.
    -- For writing, Everything is derived from OutputStream or Writer class which has a method called write() for writing a single byte or array of bytes.

	Note : The fact that we leverage multiple objects to create a single stream is what makes IO library confusing.		

-- Types Of InputStream:
	-- ByteArrayInputStream : To read from buffer in memory.
	-- StringBufferInputStream : String as input stream.
	-- FileInputStream : File as input stream.
	-- PipedInputStream : Produces data that is consumed to associated PipedOutputStream.
	-- SequenceInpputStream : Converts two or more input stream into single input stream.
	-- FilterInputStream : Abstract class that provides useful functionalities for other input stream classes.

-- Types of OutputStream:
	-- ByteArrayOutputStream : Creates a buffer in memory for the data that is sent.
	-- FileOutputStream : For sending information to a file.
	-- PipedOutputStream : Output for associated PipedInputStream.	
	-- FilterOutputStream : Abstract class that provides useful functionalities for other output stream classes.
	
	Note: There isn't String output stream, that is handled using ByteArrayOutputStream.
	
-- FilterInputStream
	-- DataInputStream : To read primitives and String object.
	-- BufferedInputStream : Read from a buffer rather than physical devices.

-- FilterOutputStream
	-- DataOutputStream : To format stream of data(primitive data and String) in a way that in can be properly reconstrcuted by DataInputStream.
	-- BufferedOutputStream : To write stream data to buffer insted of doing write on a physical device everytime.

Note: Reader/Writer is used over older InputStreamReader and OutputStreamWriter because it supports unicode (character stream) while Reader/Writer only
	  supports byte stream.
	  
-- when we need to use readLine() then we should use BufferedReader/BufferedInputStream and not DataInputStream, for all other places we can use DataInputStream.
e.g. BufferedReader in = new BufferedReader(new FileReader(file));
     while(in.readLine() == null)

-- RandomAccessFile :

It is used to access file of fixed record size, seek() method in this class is used for random access of a record.
This works only with file.

However, this is replaced with nio memory-mapped files in newer versions of java.


-- Input from memory :

StringReader in = new StringReader(BufferedInputFile.read("Filename.java"));

-- Reading in bytes:

DataInputStream in = new DataInputStream(new ByteArrayInputStream(BufferedInputFile.read("Filename.java").getBytes())); 

-- Basic file output :

we should always buffer the output as clock cycles of different devices can be mismatched leading to performance nightmare.

PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(file)));

-- PipedStreams :

PipedInputStream, PipedOutputStream, PipedReader and PrintWriter are covered in concurrency chapter since they are used to communicate between tasks.	  

-- Standard I/O :

Standard input :
BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in));
while(stdIn.readLine() != null)

Standard output :

Either System.out or PrintWriter out = new PrintWriter(System.out, true);

we have some utility method to redirect output:

System.setIn(stdIn);
System.setOut(out);
System.setErr(out);

-- Process control :

it is used for executing kernel functions from java.

we need to use OSExecute command :

OSExecute.command("javap JavaClassName");

-- NIO 

package is java.nio.*;

it is used for speed.

concept of channel and buffer.

channel is basically stream of data and buffer is where you put chunks of data or read chunks of data.

nio operates only at byte level e.g. java.nio.ByteBuffer

Example :

FileChannel fc = new FileOutputStream("data.txt").getChannel(); // creates a channel or stream of data.
To write :

fc.write(ByteBuffer.wrap("Some text".getBytes()));
fc.close();

To read :

ByteBuffer buff = ByteBuffer.allocate(<some application tested size>);
fc.read(buff);


--- Endians (Important) :

Big Endian : Most significant byte into lowest memory address (ending with big)
Little Endian : Most significant byte into highest memory address (ending with small)

It is important because multiple byte storage like int, float etc can generate corrupt data if sender and receiver are using different 
endians to send/receive data.

ByteBuffer and data sent over network always uses Big Endian order.


we can change endianness using order() method of ByteBuffer.

ByteBuffer bb = ByteBuffer.wrap(new byte[12]);
bb.asCharBuffer().put("abcdef");
bb.order(ByteOrder.BIG_ENDIAN); // similarly, ByteOrder.LITTLE_ENDIAN.
print(Arrays.toString(bb.array()));

-- Memory Mapped files :

It allows us to create/modify file that are too big to bring into memory.

Example code :

import java.nio.*;
import java.nio.channels.*;

import java.io.*;

public class LargeMappedFiles {
static int length = 0x8FFFFFF; // 128 MB

psvm(String[] args) throws Exception{

MappedByteBuffer out = new RandomAccessFile("test.dat","rw").getChannel().map(FileChannel.MapMode.READ_WRITE,0,length);
for(int i=0; i<length; i++){
out.put((byte)'x');
}

sout("Finished writing");
for(int i=length/2; i<length/2+6; i++)
sout((char)out.get(i));

// Doubt :::: What is a direct buffer ?
}
}


continue : 715
